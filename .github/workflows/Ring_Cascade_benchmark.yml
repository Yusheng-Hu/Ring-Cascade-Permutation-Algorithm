name: RCPA-Performance-Benchmark

on:
  workflow_dispatch:

concurrency:
  group: rcpa-readme-sync
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  benchmark:
    name: RCPA Sequential Benchmark
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect CPU Info
      run: |
        CPU_NAME=$(lscpu | grep 'Model name' | cut -f 2 -d ":" | sed 's/^[ \t]*//')
        if [[ "$CPU_NAME" == *"AMD"* ]]; then VENDOR="AMD"; else VENDOR="INTEL"; fi
        echo "CPU_MODEL=$CPU_NAME" >> $GITHUB_ENV
        echo "VENDOR=$VENDOR" >> $GITHUB_ENV

    - name: Compile RCPA
      run: |
        g++ -O3 -std=c++11 -march=native -ffast-math -fomit-frame-pointer \
        cpp/Ring_Cascade_Permutation_Algorithm.cpp -o rcpa_bin -pthread

    - name: Run Sequential Benchmarks and Update README
      shell: python
      run: |
        import os, subprocess, re
        from datetime import datetime, timezone

        # 1. Environment and Markers
        n_factors = [10, 11, 12, 13]
        vendor = os.environ.get('VENDOR', 'INTEL')
        cpu_model = os.environ.get('CPU_MODEL', 'Unknown')
        timestamp = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
        
        start_m = f"[//]: # (RCPA_PERFORMANCE_{vendor}_START)"
        end_m = f"[//]: # (RCPA_PERFORMANCE_{vendor}_END)"
        
        with open("README.md", "r", encoding="utf-8") as f:
            readme = f.read()

        if start_m not in readme or end_m not in readme:
            print(f"Error: Markers {start_m} or {end_m} not found!"); exit(1)

        # 2. Execute N-factors and Store Results
        results = {}
        for n in n_factors:
            print(f"Running N={n}...")
            # Use capture_output to get metrics
            res = subprocess.run(["./rcpa_bin", str(n)], capture_output=True, text=True)
            match = re.search(r"TIME_SEC: ([\d.]+)", res.stdout)
            if match:
                # FIXED: Exactly 4 columns to match your header
                # | Algorithm | N-Factor | Execution Time | Status |
                results[n] = f"| **RCPA** | **{n}** | {match.group(1)} s | âœ… |"

        # 3. Generate Table Content
        # Re-generating the entire block inside markers to ensure correct formatting
        table_block = (
            f"### ðŸš€ RCPA Performance Report (N={max(n_factors)})\n"
            f"- **Last Run:** `{timestamp}`\n"
            f"- **Processor:** `{cpu_model}`\n\n"
            f"| Algorithm | N-Factor | Execution Time | Status |\n"
            f"| :--- | :--- | :--- | :--- |\n"
        )
        for n in sorted(results.keys()):
            table_block += results[n] + "\n"

        # 4. Splice with MANDATORY empty lines before/after markers
        parts_before = readme.split(start_m)[0]
        parts_after = readme.split(end_m)[1]
        
        # Double \n ensures the HTML comment marker is invisible and doesn't break the table
        new_readme = f"{parts_before}{start_m}\n\n{table_block.strip()}\n\n{end_m}{parts_after}"

        with open("README.md", "w", encoding="utf-8") as f:
            f.write(new_readme)

    - name: Synchronized Push
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        git add README.md
        if git commit -m "docs: correct RCPA table format and status column [skip ci]"; then
          # Since it's sequential, simple push is safe
          git push origin main
        else
          echo "No changes to commit"
        fi
