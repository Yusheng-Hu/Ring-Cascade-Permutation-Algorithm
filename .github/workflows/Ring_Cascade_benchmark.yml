name: RCPA-Performance-Benchmark

on:
  workflow_dispatch:
  # Manual trigger with no inputs required, runs 10 to 13 automatically

concurrency:
  group: rcpa-readme-sync
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  benchmark:
    name: RCPA Benchmark (N=${{ matrix.n_factor }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      # Ensure jobs run sequentially to avoid git push conflicts
      max-parallel: 1 
      matrix:
        n_factor: [10, 11, 12, 13]

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect CPU Info
      run: |
        # Extract CPU model name and determine vendor
        CPU_NAME=$(lscpu | grep 'Model name' | cut -f 2 -d ":" | sed 's/^[ \t]*//')
        if [[ "$CPU_NAME" == *"AMD"* ]]; then VENDOR="AMD"; else VENDOR="INTEL"; fi
        echo "CPU_MODEL=$CPU_NAME" >> $GITHUB_ENV
        echo "VENDOR=$VENDOR" >> $GITHUB_ENV

    - name: Compile RCPA
      run: |
        # Compile the C++ source with optimization flags
        g++ -O3 -std=c++11 -march=native -ffast-math -fomit-frame-pointer \
        cpp/Ring_Cascade_Permutation_Algorithm.cpp -o rcpa_bin -pthread

    - name: Execute RCPA Benchmark
      run: |
        # Execute the binary for the current N value in the matrix
        ./rcpa_bin ${{ matrix.n_factor }} > result_rcpa.txt
        cat result_rcpa.txt

    - name: Inject into README via Python
      shell: python
      run: |
        import os, sys, re
        from datetime import datetime, timedelta, timezone

        # 1. Handle Timezone (UTC+8)
        tz_utc_8 = timezone(timedelta(hours=8))
        now_beijing = datetime.now(timezone.utc).astimezone(tz_utc_8)
        timestamp_str = now_beijing.strftime('%Y-%m-%d %H:%M:%S GMT+8')

        vendor = os.environ.get('VENDOR', 'INTEL')
        start_m = f"[//]: # (RCPA_PERFORMANCE_{vendor}_START)"
        end_m = f"[//]: # (RCPA_PERFORMANCE_{vendor}_END)"
        
        # 2. Parse benchmark results
        with open("result_rcpa.txt", "r") as f:
            log = f.read()
        
        match = re.search(r"\[METRIC_START\]\nN_VALUE: (\d+)\nTIME_SEC: ([\d.]+)\n\[METRIC_END\]", log)
        if not match:
            print("Error: Metrics not found in output!")
            sys.exit(1)
            
        n_val = match.group(1)
        time_sec = match.group(2)
        cpu_model = os.environ.get('CPU_MODEL', 'Unknown')

        # 3. Construct the new row for the table
        new_row = f"| **RCPA** | **{n_val}** | {time_sec} s | `{cpu_model}` | âœ… |"
        
        with open("README.md", "r", encoding="utf-8") as f:
            readme = f.read()
            
        if start_m in readme and end_m in readme:
            parts = readme.split(start_m)
            prefix = parts[0]
            middle_and_suffix = parts[1].split(end_m)
            content = middle_and_suffix[0].strip()
            suffix = middle_and_suffix[1]
            
            # Initialize table header if not exists
            if "| Algorithm |" not in content:
                content = "| Algorithm | N | Time | CPU | Status |\n| :--- | :--- | :--- | :--- | :--- |"
            
            # 4. Check if N-value row already exists to prevent duplicate/overwrite issues
            # Using regex to find the specific row for this N value
            n_row_pattern = rf"\| \*\*RCPA\*\* \| \*\*{n_val}\*\* \|.*"
            if re.search(n_row_pattern, content):
                # Update existing row
                updated_content = re.sub(n_row_pattern, new_row, content)
            else:
                # Append new row
                updated_content = content + "\n" + new_row
            
            # Update the specific "Last Run" line if you have one in the template
            # If you want to update the timestamp in the README, uncomment the lines below:
            # readme_header_pattern = r"Last Run:.*"
            # prefix = re.sub(readme_header_pattern, f"Last Run: `{timestamp_str}`", prefix)

            new_readme = f"{prefix}{start_m}\n{updated_content}\n{end_m}{suffix}"
            
            with open("README.md", "w", encoding="utf-8") as f:
                f.write(new_readme)
        else:
            print(f"Error: Marker {start_m} not found in README.md")
            sys.exit(1)

    - name: Synchronized Push
      run: |
        # Configure git and push changes sequentially
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        
        # Pull latest changes (rebase) to handle sequential updates
        git pull origin main --rebase
        git add README.md
        
        if git commit -m "docs: update RCPA benchmark N=${{ matrix.n_factor }} for ${{ env.VENDOR }} [skip ci]"; then
          git push origin main
        else
          echo "No changes to commit"
        fi