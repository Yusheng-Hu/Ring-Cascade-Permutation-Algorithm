name: RCPA-Performance-Benchmark

on:
  workflow_dispatch:
  # Manual trigger with no inputs required, runs 10 to 13 automatically

concurrency:
  group: rcpa-readme-sync
  cancel-in-progress: false

permissions:
  contents: write

jobs:
  benchmark:
    name: RCPA Benchmark (N=${{ matrix.n_factor }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        # Automatically iterate through N=10, 11, 12, 13
        n_factor: [10, 11, 12, 13]

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Detect CPU Info
      run: |
        CPU_NAME=$(lscpu | grep 'Model name' | cut -f 2 -d ":" | sed 's/^[ \t]*//')
        if [[ "$CPU_NAME" == *"AMD"* ]]; then VENDOR="AMD"; else VENDOR="INTEL"; fi
        echo "CPU_MODEL=$CPU_NAME" >> $GITHUB_ENV
        echo "VENDOR=$VENDOR" >> $GITHUB_ENV

    - name: Compile RCPA
      run: |
        g++ -O3 -std=c++11 -march=native -ffast-math -fomit-frame-pointer \
        cpp/Ring_Cascade_Permutation_Algorithm.cpp -o rcpa_bin -pthread

    - name: Execute RCPA Benchmark
      run: |
        # Run with the current matrix N value
        ./rcpa_bin ${{ matrix.n_factor }} > result_rcpa.txt
        cat result_rcpa.txt

    - name: Inject into README via Python
      shell: python
      run: |
        import os, sys, re
        
        vendor = os.environ.get('VENDOR', 'INTEL')
        start_m = f"[//]: # (RCPA_PERFORMANCE_{vendor}_START)"
        end_m = f"[//]: # (RCPA_PERFORMANCE_{vendor}_END)"
        
        with open("result_rcpa.txt", "r") as f:
            log = f.read()
        
        # Regex matches the [METRIC_START] block from your C++ code
        match = re.search(r"\[METRIC_START\]\nN_VALUE: (\d+)\nTIME_SEC: ([\d.]+)\n\[METRIC_END\]", log)
        if not match:
            print("Error: Metrics not found!")
            sys.exit(1)
            
        n_val = match.group(1)
        time_sec = match.group(2)
        timestamp = os.popen("date -u +'%Y-%m-%d %H:%M:%S UTC'").read().strip()
        cpu_model = os.environ.get('CPU_MODEL', 'Unknown')

        # Generate single row for the comparison table
        # Pre-formatting for future PP/Heaps rows
        new_row = f"| **RCPA** | **{n_val}** | {time_sec} s | `{cpu_model}` | âœ… |\n"
        
        with open("README.md", "r", encoding="utf-8") as f:
            readme = f.read()
            
        if start_m in readme and end_m in readme:
            parts = readme.split(start_m)
            prefix = parts[0]
            suffix = parts[1].split(end_m)[1]
            content = parts[1].split(end_m)[0].strip()
            
            # Initialize table header if first run
            if "| Algorithm |" not in content:
                content = "\n| Algorithm | N | Time | CPU | Status |\n| :--- | :--- | :--- | :--- | :--- |\n"
            
            # Append new result row
            updated_content = content.strip() + "\n" + new_row
            
            new_readme = f"{prefix}{start_m}\n{updated_content}\n{end_m}{suffix}"
            with open("README.md", "w", encoding="utf-8") as f:
                f.write(new_readme)
        else:
            sys.exit(1)

    - name: Synchronized Push
      run: |
        git config --global user.name "github-actions[bot]"
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        # Using loop to handle parallel matrix update collisions
        for i in {1..10}; do
          git add README.md
          if git commit -m "docs: update benchmark N=${{ matrix.n_factor }} [skip ci]"; then
            git pull --rebase origin main
            git push origin main && exit 0
          else
            exit 0
          fi
          sleep $(( (RANDOM % 10) + 5 ))
        done